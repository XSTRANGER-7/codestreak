{
  "1": {
    "id": "1",
    "title": "Two Sum",
    "difficulty": "Easy",
    "category": "algorithms",
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.",
    "constraints": [
      "2 <= nums.length <= 10⁴",
      "-10⁹ <= nums[i] <= 10⁹",
      "-10⁹ <= target <= 10⁹",
      "Only one valid answer exists."
    ],
    "examples": [
      {
        "input": "nums = [2,7,11,15], target = 9",
        "output": "[0,1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3,2,4], target = 6",
        "output": "[1,2]"
      },
      {
        "input": "nums = [3,3], target = 6",
        "output": "[0,1]"
      }
    ],
    "starterCode": {
      "cpp": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        // Write your code here\n        \n    }\n};",
      "java": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        // Write your code here\n        \n    }\n}",
      "python": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        # Write your code here\n        "
    }
  },
  "2": {
    "id": "2",
    "title": "Add Two Numbers",
    "difficulty": "Medium",
    "category": "algorithms",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.",
    "constraints": [
      "The number of nodes in each linked list is in the range [1, 100].",
      "0 <= Node.val <= 9",
      "It is guaranteed that the list represents a number that does not have leading zeros."
    ],
    "examples": [
      {
        "input": "l1 = [2,4,3], l2 = [5,6,4]",
        "output": "[7,0,8]",
        "explanation": "342 + 465 = 807."
      },
      {
        "input": "l1 = [0], l2 = [0]",
        "output": "[0]"
      },
      {
        "input": "l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]",
        "output": "[8,9,9,9,0,0,0,1]"
      }
    ],
    "starterCode": {
      "cpp": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        // Write your code here\n        \n    }\n};",
      "java": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        // Write your code here\n        \n    }\n}",
      "python": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        # Write your code here\n        "
    }
  },
  "3": {
    "id": "3",
    "title": "Longest Substring Without Repeating Characters",
    "difficulty": "Medium",
    "category": "algorithms",
    "description": "Given a string s, find the length of the longest substring without repeating characters.",
    "constraints": [
      "0 <= s.length <= 5 * 10⁴",
      "s consists of English letters, digits, symbols and spaces."
    ],
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "The answer is \"abc\", with the length of 3."
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "The answer is \"b\", with the length of 1."
      },
      {
        "input": "s = \"pwwkew\"",
        "output": "3",
        "explanation": "The answer is \"wke\", with the length of 3."
      }
    ],
    "starterCode": {
      "cpp": "class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        // Write your code here\n        \n    }\n};",
      "java": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        // Write your code here\n        \n    }\n}",
      "python": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        # Write your code here\n        "
    }
  },
  "4": {
    "id": "4",
    "title": "Median of Two Sorted Arrays",
    "difficulty": "Hard",
    "category": "algorithms",
    "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).",
    "constraints": [
      "nums1.length == m",
      "nums2.length == n",
      "0 <= m <= 1000",
      "0 <= n <= 1000",
      "1 <= m + n <= 2000",
      "-10⁶ <= nums1[i], nums2[i] <= 10⁶"
    ],
    "examples": [
      {
        "input": "nums1 = [1,3], nums2 = [2]",
        "output": "2.00000",
        "explanation": "merged array = [1,2,3] and median is 2."
      },
      {
        "input": "nums1 = [1,2], nums2 = [3,4]",
        "output": "2.50000",
        "explanation": "merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
      }
    ],
    "starterCode": {
      "cpp": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        // Write your code here\n        \n    }\n};",
      "java": "class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        // Write your code here\n        \n    }\n}",
      "python": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        # Write your code here\n        "
    }
  },
  "5": {
    "id": "5",
    "title": "Valid Parentheses",
    "difficulty": "Easy",
    "category": "dataStructures",
    "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.",
    "constraints": [
      "1 <= s.length <= 10⁴",
      "s consists of parentheses only '()[]{}'"
    ],
    "examples": [
      {
        "input": "s = \"()\"",
        "output": "true"
      },
      {
        "input": "s = \"()[]{}\"",
        "output": "true"
      },
      {
        "input": "s = \"(]\"",
        "output": "false"
      }
    ],
    "starterCode": {
      "cpp": "class Solution {\npublic:\n    bool isValid(string s) {\n        // Write your code here\n        \n    }\n};",
      "java": "class Solution {\n    public boolean isValid(String s) {\n        // Write your code here\n        \n    }\n}",
      "python": "class Solution:\n    def isValid(self, s: str) -> bool:\n        # Write your code here\n        "
    }
  },
  "6": {
    "id": "6",
    "title": "Binary Tree Inorder Traversal",
    "difficulty": "Easy",
    "category": "dataStructures",
    "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [1,null,2,3]",
        "output": "[1,3,2]"
      },
      {
        "input": "root = []",
        "output": "[]"
      },
      {
        "input": "root = [1]",
        "output": "[1]"
      }
    ],
    "starterCode": {
      "cpp": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        // Write your code here\n        \n    }\n};",
      "java": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        // Write your code here\n        \n    }\n}",
      "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        # Write your code here\n        "
    }
  },
  "7": {
    "id": "7",
    "title": "Maximum Depth of Binary Tree",
    "difficulty": "Easy",
    "category": "dataStructures",
    "description": "Given the root of a binary tree, return its maximum depth.\n\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10⁴].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "3"
      },
      {
        "input": "root = [1,null,2]",
        "output": "2"
      }
    ],
    "starterCode": {
      "cpp": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        // Write your code here\n        \n    }\n};",
      "java": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        // Write your code here\n        \n    }\n}",
      "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        # Write your code here\n        "
    }
  },
  "8": {
    "id": "8",
    "title": "Design Twitter",
    "difficulty": "Medium",
    "category": "systemDesign",
    "description": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and see the 10 most recent tweets in the user's news feed.\n\nImplement the Twitter class:\n\n- Twitter() Initializes your twitter object.\n- void postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId.\n- List<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed.\n- void follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.\n- void unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.",
    "constraints": [
      "1 <= userId, followerId, followeeId <= 500",
      "0 <= tweetId <= 10⁴",
      "All the tweets have unique IDs.",
      "At most 3 * 10⁴ calls will be made to postTweet, getNewsFeed, follow, and unfollow."
    ],
    "examples": [
      {
        "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"]",
        "output": "[null, null, [5], null, null, [6, 5], null, [5]]"
      }
    ],
    "starterCode": {
      "cpp": "class Twitter {\npublic:\n    Twitter() {\n        \n    }\n    \n    void postTweet(int userId, int tweetId) {\n        \n    }\n    \n    vector<int> getNewsFeed(int userId) {\n        \n    }\n    \n    void follow(int followerId, int followeeId) {\n        \n    }\n    \n    void unfollow(int followerId, int followeeId) {\n        \n    }\n};",
      "java": "class Twitter {\n\n    public Twitter() {\n        \n    }\n    \n    public void postTweet(int userId, int tweetId) {\n        \n    }\n    \n    public List<Integer> getNewsFeed(int userId) {\n        \n    }\n    \n    public void follow(int followerId, int followeeId) {\n        \n    }\n    \n    public void unfollow(int followerId, int followeeId) {\n        \n    }\n}",
      "python": "class Twitter:\n\n    def __init__(self):\n        \n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        \n\n    def getNewsFeed(self, userId: int) -> List[int]:\n        \n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        \n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        "
    }
  },
  "9": {
    "id": "9",
    "title": "Design URL Shortener",
    "difficulty": "Medium",
    "category": "systemDesign",
    "description": "Design a URL shortening service like TinyURL. The service should provide two functions:\n\n1. encode(longUrl): Takes a long URL and returns a short URL.\n2. decode(shortUrl): Takes a short URL and returns the original long URL.\n\nRequirements:\n- The short URL should be as short as possible.\n- The same long URL should always produce the same short URL.\n- The system should handle collisions.",
    "constraints": [
      "1 <= url.length <= 10⁴",
      "url is guaranteed to be a valid URL."
    ],
    "examples": [
      {
        "input": "url = \"https://leetcode.com/problems/design-tinyurl\"",
        "output": "https://leetcode.com/problems/design-tinyurl"
      }
    ],
    "starterCode": {
      "cpp": "class Solution {\npublic:\n    // Encodes a URL to a shortened URL.\n    string encode(string longUrl) {\n        \n    }\n\n    // Decodes a shortened URL to its original URL.\n    string decode(string shortUrl) {\n        \n    }\n};",
      "java": "public class Codec {\n\n    // Encodes a URL to a shortened URL.\n    public String encode(String longUrl) {\n        \n    }\n\n    // Decodes a shortened URL to its original URL.\n    public String decode(String shortUrl) {\n        \n    }\n}",
      "python": "class Codec:\n\n    def encode(self, longUrl: str) -> str:\n        \"\"\"Encodes a URL to a shortened URL.\n        \"\"\"\n        \n\n    def decode(self, shortUrl: str) -> str:\n        \"\"\"Decodes a shortened URL to its original URL.\n        \"\"\"\n        "
    }
  },
  "10": {
    "id": "10",
    "title": "SQL Query Optimization",
    "difficulty": "Hard",
    "category": "databases",
    "description": "Given a slow-running SQL query, optimize it to improve performance.\n\nConsider the following table:\nEmployees (id, name, department_id, salary, hire_date)\nDepartments (id, name, location)\n\nOptimize this query:\nSELECT e.name, d.name as department\nFROM Employees e\nJOIN Departments d ON e.department_id = d.id\nWHERE e.salary > 50000\nORDER BY e.hire_date DESC;",
    "constraints": [
      "The Employees table has 1 million rows.",
      "The Departments table has 100 rows.",
      "Consider adding indexes.",
      "Consider query structure optimization."
    ],
    "examples": [
      {
        "input": "Original query execution time: 5 seconds",
        "output": "Optimized query execution time: < 1 second"
      }
    ],
    "starterCode": {
      "cpp": "// SQL Query Optimization\n// Write your optimized query here\nstring optimizedQuery = R\"(\n    -- Your optimized SQL query\n)\";",
      "java": "// SQL Query Optimization\n// Write your optimized query here\nString optimizedQuery = \"\"\"\n    -- Your optimized SQL query\n\"\"\";",
      "python": "# SQL Query Optimization\n# Write your optimized query here\noptimized_query = \"\"\"\n    -- Your optimized SQL query\n\"\"\""
    }
  },
  "11": {
    "id": "11",
    "title": "Database Indexing",
    "difficulty": "Medium",
    "category": "databases",
    "description": "Design an appropriate indexing strategy for a database table to optimize query performance.\n\nGiven a Users table with columns:\n- id (PRIMARY KEY)\n- email\n- username\n- created_at\n- last_login\n- country\n\nCommon queries:\n1. SELECT * FROM Users WHERE email = 'user@example.com'\n2. SELECT * FROM Users WHERE username = 'john_doe'\n3. SELECT * FROM Users WHERE country = 'US' ORDER BY created_at DESC\n4. SELECT * FROM Users WHERE last_login > '2024-01-01'\n\nDesign the optimal index strategy.",
    "constraints": [
      "The table has 10 million rows.",
      "Email must be unique.",
      "Username must be unique.",
      "Optimize for read performance.",
      "Consider index size and maintenance cost."
    ],
    "examples": [
      {
        "input": "Query: SELECT * FROM Users WHERE email = 'user@example.com'",
        "output": "Execution time: < 10ms with proper index"
      }
    ],
    "starterCode": {
      "cpp": "// Database Indexing Strategy\n// Write your CREATE INDEX statements\nstring indexStrategy = R\"(\n    -- Your index creation statements\n)\";",
      "java": "// Database Indexing Strategy\n// Write your CREATE INDEX statements\nString indexStrategy = \"\"\"\n    -- Your index creation statements\n\"\"\";",
      "python": "# Database Indexing Strategy\n# Write your CREATE INDEX statements\nindex_strategy = \"\"\"\n    -- Your index creation statements\n\"\"\""
    }
  },
  "12": {
    "id": "12",
    "title": "Merge Sort Implementation",
    "difficulty": "Medium",
    "category": "algorithms",
    "description": "Implement the merge sort algorithm to sort an array in ascending order.\n\nMerge sort is a divide-and-conquer algorithm that:\n1. Divides the array into two halves\n2. Recursively sorts each half\n3. Merges the sorted halves back together\n\nTime Complexity: O(n log n)\nSpace Complexity: O(n)",
    "constraints": [
      "1 <= arr.length <= 5 * 10⁴",
      "-10⁹ <= arr[i] <= 10⁹"
    ],
    "examples": [
      {
        "input": "arr = [5, 2, 3, 1]",
        "output": "[1, 2, 3, 5]"
      },
      {
        "input": "arr = [5, 1, 1, 2, 0, 0]",
        "output": "[0, 0, 1, 1, 2, 5]"
      }
    ],
    "starterCode": {
      "cpp": "class Solution {\npublic:\n    vector<int> mergeSort(vector<int>& arr) {\n        // Write your code here\n        \n    }\n    \n    void merge(vector<int>& arr, int left, int mid, int right) {\n        // Write merge logic here\n        \n    }\n};",
      "java": "class Solution {\n    public int[] mergeSort(int[] arr) {\n        // Write your code here\n        \n    }\n    \n    private void merge(int[] arr, int left, int mid, int right) {\n        // Write merge logic here\n        \n    }\n}",
      "python": "class Solution:\n    def mergeSort(self, arr: List[int]) -> List[int]:\n        # Write your code here\n        \n    \n    def merge(self, arr: List[int], left: int, mid: int, right: int) -> None:\n        # Write merge logic here\n        "
    }
  },
  "13": {
    "id": "13",
    "title": "Graph Traversal BFS/DFS",
    "difficulty": "Medium",
    "category": "algorithms",
    "description": "Implement both Breadth-First Search (BFS) and Depth-First Search (DFS) algorithms for graph traversal.\n\nGiven an undirected graph represented as an adjacency list, implement:\n1. BFS - visits nodes level by level\n2. DFS - visits nodes by going as deep as possible before backtracking\n\nReturn the order of nodes visited.",
    "constraints": [
      "1 <= number of nodes <= 1000",
      "0 <= number of edges <= 10000",
      "The graph may contain cycles.",
      "The graph may not be connected."
    ],
    "examples": [
      {
        "input": "graph = [[1,2], [0,3,4], [0], [1], [1]], start = 0",
        "output": "BFS: [0,1,2,3,4], DFS: [0,1,3,4,2]"
      }
    ],
    "starterCode": {
      "cpp": "class Solution {\npublic:\n    vector<int> bfs(vector<vector<int>>& graph, int start) {\n        // Write your BFS code here\n        \n    }\n    \n    vector<int> dfs(vector<vector<int>>& graph, int start) {\n        // Write your DFS code here\n        \n    }\n};",
      "java": "class Solution {\n    public List<Integer> bfs(List<List<Integer>> graph, int start) {\n        // Write your BFS code here\n        \n    }\n    \n    public List<Integer> dfs(List<List<Integer>> graph, int start) {\n        // Write your DFS code here\n        \n    }\n}",
      "python": "class Solution:\n    def bfs(self, graph: List[List[int]], start: int) -> List[int]:\n        # Write your BFS code here\n        \n    \n    def dfs(self, graph: List[List[int]], start: int) -> List[int]:\n        # Write your DFS code here\n        "
    }
  },
  "14": {
    "id": "14",
    "title": "Dynamic Programming - Fibonacci",
    "difficulty": "Easy",
    "category": "algorithms",
    "description": "Calculate the nth Fibonacci number using dynamic programming.\n\nThe Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n\nEach number is the sum of the two preceding ones.\n\nImplement an efficient solution using:\n1. Memoization (top-down)\n2. Tabulation (bottom-up)\n\nOptimize for both time and space complexity.",
    "constraints": [
      "0 <= n <= 30"
    ],
    "examples": [
      {
        "input": "n = 2",
        "output": "1"
      },
      {
        "input": "n = 3",
        "output": "2"
      },
      {
        "input": "n = 4",
        "output": "3"
      }
    ],
    "starterCode": {
      "cpp": "class Solution {\npublic:\n    int fib(int n) {\n        // Write your code here\n        \n    }\n};",
      "java": "class Solution {\n    public int fib(int n) {\n        // Write your code here\n        \n    }\n}",
      "python": "class Solution:\n    def fib(self, n: int) -> int:\n        # Write your code here\n        "
    }
  },
  "15": {
    "id": "15",
    "title": "Hash Table Implementation",
    "difficulty": "Medium",
    "category": "dataStructures",
    "description": "Implement a hash table from scratch with the following operations:\n\n1. put(key, value): Insert or update a key-value pair\n2. get(key): Retrieve the value associated with the key\n3. remove(key): Remove the key-value pair\n\nRequirements:\n- Handle collisions using chaining or open addressing\n- Implement automatic resizing when load factor exceeds 0.75\n- Support generic keys and values",
    "constraints": [
      "0 <= key, value <= 10⁶",
      "At most 10⁴ calls will be made to put, get, and remove.",
      "Initial capacity should be 16.",
      "Resize when load factor > 0.75"
    ],
    "examples": [
      {
        "input": "[\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"]",
        "output": "[null, null, null, 1, -1, null, 2, null, -1]"
      }
    ],
    "starterCode": {
      "cpp": "class MyHashMap {\npublic:\n    MyHashMap() {\n        \n    }\n    \n    void put(int key, int value) {\n        \n    }\n    \n    int get(int key) {\n        \n    }\n    \n    void remove(int key) {\n        \n    }\n};",
      "java": "class MyHashMap {\n\n    public MyHashMap() {\n        \n    }\n    \n    public void put(int key, int value) {\n        \n    }\n    \n    public int get(int key) {\n        \n    }\n    \n    public void remove(int key) {\n        \n    }\n}",
      "python": "class MyHashMap:\n\n    def __init__(self):\n        \n\n    def put(self, key: int, value: int) -> None:\n        \n\n    def get(self, key: int) -> int:\n        \n\n    def remove(self, key: int) -> None:\n        "
    }
  },
  "16": {
    "id": "16",
    "title": "Binary Search Implementation",
    "difficulty": "Hard",
    "category": "dataStructures",
    "description": "Implement various binary search algorithms:\n\n1. Standard binary search\n2. Find first occurrence of a target\n3. Find last occurrence of a target\n4. Find insertion position\n5. Search in rotated sorted array\n\nAll implementations should have O(log n) time complexity.",
    "constraints": [
      "1 <= arr.length <= 10⁴",
      "-10⁴ <= arr[i] <= 10⁴",
      "arr is sorted in ascending order (except for rotated array).",
      "All the integers in arr are unique."
    ],
    "examples": [
      {
        "input": "arr = [1,2,3,4,5,6,7], target = 4",
        "output": "3"
      },
      {
        "input": "arr = [1,2,2,2,3,4,5], target = 2",
        "output": "First: 1, Last: 3"
      }
    ],
    "starterCode": {
      "cpp": "class Solution {\npublic:\n    int binarySearch(vector<int>& arr, int target) {\n        // Write your code here\n        \n    }\n    \n    int findFirst(vector<int>& arr, int target) {\n        // Write your code here\n        \n    }\n    \n    int findLast(vector<int>& arr, int target) {\n        // Write your code here\n        \n    }\n};",
      "java": "class Solution {\n    public int binarySearch(int[] arr, int target) {\n        // Write your code here\n        \n    }\n    \n    public int findFirst(int[] arr, int target) {\n        // Write your code here\n        \n    }\n    \n    public int findLast(int[] arr, int target) {\n        // Write your code here\n        \n    }\n}",
      "python": "class Solution:\n    def binarySearch(self, arr: List[int], target: int) -> int:\n        # Write your code here\n        \n    \n    def findFirst(self, arr: List[int], target: int) -> int:\n        # Write your code here\n        \n    \n    def findLast(self, arr: List[int], target: int) -> int:\n        # Write your code here\n        "
    }
  },
  "17": {
    "id": "17",
    "title": "BST Implementation",
    "difficulty": "Easy",
    "category": "dataStructures",
    "description": "Implement a Binary Search Tree (BST) with the following operations:\n\n1. insert(val): Insert a value into the BST\n2. search(val): Search for a value in the BST\n3. delete(val): Delete a value from the BST\n4. inorder(): Return inorder traversal\n5. preorder(): Return preorder traversal\n6. postorder(): Return postorder traversal\n\nMaintain BST property: left < root < right",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10⁴].",
      "-10⁸ <= Node.val <= 10⁸",
      "All the values are unique."
    ],
    "examples": [
      {
        "input": "[\"BST\", \"insert\", \"insert\", \"insert\", \"search\", \"inorder\"]",
        "output": "[null, null, null, null, true, [1, 2, 3]]"
      }
    ],
    "starterCode": {
      "cpp": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n * };\n */\nclass BST {\npublic:\n    BST() {\n        \n    }\n    \n    void insert(int val) {\n        \n    }\n    \n    bool search(int val) {\n        \n    }\n    \n    void deleteNode(int val) {\n        \n    }\n};",
      "java": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n * }\n */\nclass BST {\n\n    public BST() {\n        \n    }\n    \n    public void insert(int val) {\n        \n    }\n    \n    public boolean search(int val) {\n        \n    }\n    \n    public void deleteNode(int val) {\n        \n    }\n}",
      "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BST:\n\n    def __init__(self):\n        \n\n    def insert(self, val: int) -> None:\n        \n\n    def search(self, val: int) -> bool:\n        \n\n    def deleteNode(self, val: int) -> None:\n        "
    }
  },
  "18": {
    "id": "18",
    "title": "Matrix Operations",
    "difficulty": "Medium",
    "category": "dataStructures",
    "description": "Implement common matrix operations:\n\n1. Matrix addition\n2. Matrix multiplication\n3. Matrix transpose\n4. Matrix rotation (90 degrees clockwise)\n5. Spiral matrix traversal\n\nAll operations should be optimized for performance.",
    "constraints": [
      "1 <= matrix.length, matrix[0].length <= 100",
      "-10⁹ <= matrix[i][j] <= 10⁹",
      "For multiplication, ensure matrices are compatible."
    ],
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "Rotated: [[7,4,1],[8,5,2],[9,6,3]]"
      },
      {
        "input": "matrix = [[1,2,3],[4,5,6]]",
        "output": "Spiral: [1,2,3,6,5,4]"
      }
    ],
    "starterCode": {
      "cpp": "class Solution {\npublic:\n    vector<vector<int>> addMatrix(vector<vector<int>>& A, vector<vector<int>>& B) {\n        // Write your code here\n        \n    }\n    \n    vector<vector<int>> multiplyMatrix(vector<vector<int>>& A, vector<vector<int>>& B) {\n        // Write your code here\n        \n    }\n    \n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n        // Write your code here\n        \n    }\n    \n    void rotate(vector<vector<int>>& matrix) {\n        // Write your code here\n        \n    }\n};",
      "java": "class Solution {\n    public int[][] addMatrix(int[][] A, int[][] B) {\n        // Write your code here\n        \n    }\n    \n    public int[][] multiplyMatrix(int[][] A, int[][] B) {\n        // Write your code here\n        \n    }\n    \n    public int[][] transpose(int[][] matrix) {\n        // Write your code here\n        \n    }\n    \n    public void rotate(int[][] matrix) {\n        // Write your code here\n        \n    }\n}",
      "python": "class Solution:\n    def addMatrix(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        # Write your code here\n        \n    \n    def multiplyMatrix(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        # Write your code here\n        \n    \n    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\n        # Write your code here\n        \n    \n    def rotate(self, matrix: List[List[int]]) -> None:\n        # Write your code here\n        "
    }
  }
}
